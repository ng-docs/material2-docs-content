<html><head></head><body><div class="docs-markdown"><h1 class="docs-markdown-h1">ng-update schematic</h1><p class="docs-markdown-p"><strong>Note</strong> The CDK ng-update schematic is the foundation for the Angular Material update schematic. This is achieved by making the ng-update code for the CDK as abstract as possible.</p><p class="docs-markdown-p">This means that this document also applies for the Angular Material <code class="docs-markdown-code">ng-update</code>.</p><hr><p class="docs-markdown-p">The <code class="docs-markdown-code">ng-update</code> schematic consists of multiple migration entry-points where every entry-point targets a specific Angular CDK or Angular Material version.</p><p class="docs-markdown-p">As of right now, we have two migration entry-points that handle the breaking changes for the given target version:</p><table class="docs-markdown-table"><thead><tr class="docs-markdown-tr"><th class="docs-markdown-th">Target Version</th><th class="docs-markdown-th">Description</th></tr></thead><tbody class="docs-markdown-tbody"><tr class="docs-markdown-tr"><td class="docs-markdown-td">V6</td><td class="docs-markdown-td">Upgrade from any version to v6.0.0</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td">V7</td><td class="docs-markdown-td">Upgrade from any version to v7.0.0</td></tr></tbody></table><p class="docs-markdown-p">Note that the migrations run <em>in order</em> if multiple versions are transitively targeted. For example, consider an application which uses Angular Material v5.0.0. In case the developer runs <code class="docs-markdown-code">ng update</code>, the Angular CLI <strong>only</strong> installs V7 and runs the V6 and V7 migrations in order.</p><p class="docs-markdown-p">This shows that the we technically need to keep all migrations from V5 in this code base, because the CLI usually only installs the latest version and expects all version migrations to be present.</p><h2 class="docs-markdown-h2">Update concept</h2><p class="docs-markdown-p">The goal of the update schematic is to automatically migrate code that is affected by breaking changes of the target version. Most of the time, we can apply such automatic migrations, but there are also a few breaking changes that cannot be migrated automatically.</p><p class="docs-markdown-p">In that case, our goal should be to notify the developer about the breaking change that needs developer attention.</p><h2 class="docs-markdown-h2">Transforming TypeScript files</h2><p class="docs-markdown-p">In order to automatically migrate TypeScript source files, we take advantage of the <code class="docs-markdown-code">tslint</code> which allows us to create custom rules that can:</p><ul class="docs-markdown-ul"><li class="docs-markdown-li">Easily <code class="docs-markdown-code">visit</code> specific types of TypeScript nodes (e.g. <code class="docs-markdown-code">visitClassDeclaration</code>)</li><li class="docs-markdown-li">Structure migrations based on the <em>upgrade data</em> or type of migration (different TSLint rules)</li><li class="docs-markdown-li">Easily apply replacements / fixes for specific TypeScript nodes.</li><li class="docs-markdown-li">Easily report breaking changes at TypeScript nodes that cannot be migrated automatically</li><li class="docs-markdown-li">Double check for rule migrations (TSLint always runs rule again after migrations have been applied)</li></ul><p class="docs-markdown-p">There also other various concepts for transforming TypeScript source files, but most of them don't provide a simple API for replacements and reporting. Read more about the possible approaches below:</p><table class="docs-markdown-table"><thead><tr class="docs-markdown-tr"><th class="docs-markdown-th">Description</th><th class="docs-markdown-th">Evaluation</th></tr></thead><tbody class="docs-markdown-tbody"><tr class="docs-markdown-tr"><td class="docs-markdown-td">Regular Expressions</td><td class="docs-markdown-td">Too brittle. No type checking possible. Regular Expression <em>can</em> be used in combination with some real AST walking</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td">TypeScript transforms (no emit)</td><td class="docs-markdown-td">This would be a good solution that avoids using TSLint. No simple API for reporting and visiting specific types of nodes</td></tr><tr class="docs-markdown-tr"><td class="docs-markdown-td">Plain TypeScript AST</td><td class="docs-markdown-td">This would be similar to the TypeScript transforms. Extra effort in creating the replacement API; reporting API; walking logic</td></tr></tbody></table><h2 class="docs-markdown-h2">## Transforming CSS and HTML files</h2><p class="docs-markdown-p">Since <code class="docs-markdown-code">TSLint</code> allows us to only visit TypeScript nodes, we can technically just apply migrations for inline styles or templates which are part of the TypeScript AST. In our case, the update schematic should also apply migrations for external templates or styles. In order to archive this with TSLint, we have a customized implementation of a <code class="docs-markdown-code">TSLint.RuleWalker</code>. The custom RuleWalker which is called <code class="docs-markdown-code">ComponentWalker</code> determines external templates and stylesheets from the <em>component/directive</em> metadata.</p><p class="docs-markdown-p">The given resource files will then be wrapped inside of an in-memory TypeScript source file that can be applied to the rule walker. This ensures that only referenced resource files will be migrated and also allows us to take advantage of the simple replacement and reporting API from TSLint.</p><p class="docs-markdown-p">This also makes the rule walker API consistent with the handling of inline resource files.</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-comment">// PSEUDO CODE</span>
visitExternalTemplate(node: ts.SourceFile) {
  <span class="hljs-keyword">const</span> parsedHtml = parse5.parse(node.getFullText());

  <span class="hljs-keyword">this</span>._findOutdatedInputs(parsedHtml)
   .forEach(<span class="hljs-function"><span class="hljs-params">offsetStart</span> =&gt;</span> <span class="hljs-keyword">this</span>._addExternalFailure(offsetStart, <span class="hljs-string">'Outdated input'</span>, _myFix);}
</code></pre><h3 id="upgrade-data-for-target-versions" class="docs-header-link docs-markdown-h3"><span header-link="upgrade-data-for-target-versions"></span> Upgrade data for target versions</h3><p class="docs-markdown-p">The upgrade data for migrations is separated based on the target version. This is necessary in order to allow migrations run sequentially. For example:</p><ul class="docs-markdown-ul"><li class="docs-markdown-li">In V6: <code class="docs-markdown-code">onChange</code> has been renamed to <code class="docs-markdown-code">changed</code></li><li class="docs-markdown-li">In V7: <code class="docs-markdown-code">changed</code> has been renamed to <code class="docs-markdown-code">onValueChange</code></li></ul><p class="docs-markdown-p">If we would not run the migrations in order, or don't separate the upgrade data, we would not be able to properly handle the migrations for each target version. e.g. someone is on 5.0.0 and <em>only</em> wants to upgrade to 6.0.0. In that case he would end up with <code class="docs-markdown-code">onValueChange</code> because the non-separated upgrade data would just include: <em><code class="docs-markdown-code">onChange</code> =&gt; <code class="docs-markdown-code">onValueChange</code></em></p><p class="docs-markdown-p">Also besides separating the upgrade data based on the target version, we split the upgrade data based on the type of code that is affected by these migrations:</p><ul class="docs-markdown-ul"><li class="docs-markdown-li">See here: <a href="https://github.com/angular/material2/tree/master/src/lib/schematics/update/material/data" class="docs-markdown-a">src/lib/schematics/update/material/data</a></li></ul><h3 id="adding-upgrade-data" class="docs-header-link docs-markdown-h3"><span header-link="adding-upgrade-data"></span> Adding upgrade data</h3><p class="docs-markdown-p">Adding upgrade data is now a <strong>mandatory</strong> step before breaking changes should be merged into <code class="docs-markdown-code">upstream</code>. For simple and common breaking changes, there should be already an upgrade data file that just needs the new change inserted.</p><p class="docs-markdown-p">In case there is no upgrade data for a breaking change, we need to evaluate if there should be a single <code class="docs-markdown-code">misc</code> migration rule that is tied to that specific breaking change, or if we should create a new migration rule in a more generic way.</p><hr><p class="docs-markdown-p"><strong>Example</strong>: Adding upgrade data for a property rename<br><strong>Scenario</strong>: In Angular Material V7.0.0, we rename <code class="docs-markdown-code">MatRipple#color</code> to <code class="docs-markdown-code">MatRipple#newColor</code>.</p><p class="docs-markdown-p">First, look for an existing upgrade data file that covers similar breaking changes. In that case an existing upgrade data file for <code class="docs-markdown-code">property-names</code> already exists. Insert the new breaking change within the proper <code class="docs-markdown-code">VersionTarget</code>.</p><p class="docs-markdown-p"><em>src/lib/schematics/ng-update/material/data/property-names.ts</em></p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> propertyNames: VersionChanges&lt;MaterialPropertyNameData&gt; = {
  [TargetVersion.V7]: [
    {
      pr: <span class="hljs-string">'{PULL_REQUEST_LINK_FOR_BREAKING_CHANGE}'</span>,
      changes: [
        {
          replace: <span class="hljs-string">'color'</span>,
          replaceWith: <span class="hljs-string">'newColor'</span>,
          whitelist: {
            classes: [<span class="hljs-string">'MatRipple'</span>]
          }
        }
      ]
    }
  ],
   ...
};
</code></pre><p class="docs-markdown-p">Once the data is inserted into the upgrade data file, the update schematic will properly migrate <code class="docs-markdown-code">MatRipple#color</code> to <code class="docs-markdown-code">MatRipple#newColor</code> if someone upgrades to Angular Material V7.0.0.</p><p class="docs-markdown-p">But that's not all. It's encouraged to add a test-case for the new migration data. In this case, a test case already exists for the type of migration and we just need to add our breaking change to it. Read more about adding a test case in the next section.</p><h3 id="adding-a-breaking-change-to-a-test-case" class="docs-header-link docs-markdown-h3"><span header-link="adding-a-breaking-change-to-a-test-case"></span> Adding a breaking change to a test case</h3><p class="docs-markdown-p">Considering we added a breaking change to the update schematic, it's encouraged to add a proper test case for the new change that has been added.</p><p class="docs-markdown-p">In the scenario where a property from <code class="docs-markdown-code">MatRipple</code> has been renamed in V7, we don't need to create a new test-case file because there is already a test case for the <code class="docs-markdown-code">property-names</code> upgrade data. In that case, we just need to add the breaking change to the existing test case.</p><p class="docs-markdown-p">_src/lib/schematics/ng-update/test-cases/v7/property-names_input.ts_</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code">...

<span class="hljs-comment">/**
 * Mock definitions. This test case does not have access to @angular/material.
 */</span>
<span class="hljs-keyword">class</span> MatRipple {
  color: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/*
 * Actual test cases using the previously defined definitions.
 */</span>
<span class="hljs-keyword">class</span> A <span class="hljs-keyword">implements</span> OnInit {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> a: MatRipple</span>) {}

  ngOnInit() {
    <span class="hljs-keyword">this</span>.a.color = <span class="hljs-string">'primary'</span>;
  }
}
</code></pre><p class="docs-markdown-p">_src/lib/schematics/ng-update/test-cases/v7/property-names_expected_output.ts_</p><pre class="docs-markdown-pre"><code class="lang-ts docs-markdown-code">...

<span class="hljs-comment">/**
 * Mock definitions. This test case does not have access to @angular/material.
 */</span>
<span class="hljs-keyword">class</span> MatRipple {
  color: <span class="hljs-built_in">string</span>;
}

<span class="hljs-comment">/*
 * Actual test cases using the previously defined definitions.   
 */</span>
<span class="hljs-keyword">class</span> A <span class="hljs-keyword">implements</span> OnInit {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> a: MatRipple</span>) {}

  ngOnInit() {
    <span class="hljs-keyword">this</span>.a.newColor = <span class="hljs-string">'primary'</span>;
  }
}
</code></pre><p class="docs-markdown-p"><strong>Note</strong>: The <code class="docs-markdown-code">_input.ts</code> file will be just transformed by the V7 migrations and compared to the <code class="docs-markdown-code">_expected_output.ts</code> file. This means that it's necessary to also include the no longer valid mock declarations to the expected output file.</p></div></body></html>